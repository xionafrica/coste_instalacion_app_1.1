# -*- coding: utf-8 -*-
"""coste_instalacion.py

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1odoQ1pOLzWewpfiDTH7uf5JRPjXctIb4
"""

import tkinter as tk
from tkinter import filedialog, messagebox
import pandas as pd
import matplotlib.pyplot as plt
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
import matplotlib.patches as patches
import json

class CosteInstalacion:
    def __init__(self, excel_path):
        self.excel_path = excel_path
        self.tecnicos = set([
            "JOSE RAMÓN CASALES", "JOSE ANTONIO PÉREZ", "LUIS RIVERA",
            "JOEL GAVIRATI", "GABRIEL PÉREZ", "DAVID GARRIDO", "ERIC MARTINEZ",
            "ROBERTO SEIJO", "RAUL BARREIRO", "ELOY MOSQUERA", "DAVID GESTEIRO",
            "ANDRÉ FANDIÑO", "ALEJANDRO NÚÑEZ", "MAURO CASTELLETTI",
            "LAUREANO ÁLVAREZ", "SAMUEL MUIÑOS", "DAVID GROSSI"
        ])
        self.campos_eliminar = [
            'Formación PRL', 'No trabajó', 'SOPORTE', 'Sin intervenciones',
            'Día libre', 'enfermo', 'Preparación instalaciones',
            'Teletrabajo', 'Indispuesto', 'BASTET', 'VACACIONES', 'OFICINA'
        ]
        self.data = None
        self.data_final = None

    def cargar_datos(self):
        # Cargar el archivo Excel sin interpretar la primera fila como encabezado
        data = pd.read_excel(self.excel_path, header=None)

        # Detectar nuevos técnicos
        tecnicos_nuevos = set(data.iloc[0].astype(str).str.strip().str.upper()) - self.tecnicos - {"FECHA"}
        self.tecnicos.update(tecnicos_nuevos)

        # Filtrar filas con técnicos
        data_filtrado = data[
            ~data.apply(lambda row: any(str(val).strip().upper() in self.tecnicos for val in row.dropna().astype(str)), axis=1)
        ]

        # Procesar encabezados
        data_filtrado.reset_index(drop=True, inplace=True)
        data_filtrado.columns = data_filtrado.iloc[0].values
        data_filtrado = data_filtrado.iloc[1:].reset_index(drop=True)

        # Renombrar columnas
        data_filtrado.columns = ["fecha"] + [f"col_{i}" for i in range(1, len(data_filtrado.columns))]

        # Procesar fechas
        data_filtrado["fecha"] = pd.to_datetime(data_filtrado["fecha"], errors="coerce").dt.date

        self.data = data_filtrado
        return self.data

    def procesar_datos(self):
        if self.data is None:
            self.cargar_datos()

        # Reorganizar datos
        data_melted = self.data.melt(id_vars=["fecha"], var_name="tecnico", value_name="instalacion")
        data_org = data_melted.dropna(subset=["instalacion"])[["fecha", "instalacion"]]

        # Limpiar datos
        data_clean = data_org.copy()
        data_clean["instalacion"] = data_clean["instalacion"].str.upper()

        # Filtrar campos a eliminar
        patron = '|'.join(self.campos_eliminar)
        data_clean = data_clean[~data_clean["instalacion"].str.contains(patron, case=False, na=False)]

        # Procesar fechas y calcular horas
        data_clean["fecha"] = pd.to_datetime(data_clean["fecha"], errors="coerce")
        data_clean = data_clean.dropna(subset=["fecha", "instalacion"])

        # Calcular horas invertidas
        data_clean["horas_invertidas"] = data_clean["instalacion"].apply(self._calcular_horas)

        # Ajustar horas para instalaciones repetidas
        #data_clean["horas_invertidas"] = data_clean.groupby(["fecha", "instalacion"])["horas_invertidas"].transform(lambda x: x * 2)
        data_clean = data_clean.groupby(["fecha", "instalacion"], as_index=False).agg({"horas_invertidas": "sum"})
        self.data_final = data_clean
        return self.data_final

    def _calcular_horas(self, instalacion):
        if pd.isna(instalacion):
            return 0
        instalaciones = instalacion.split(",")
        return 8 / len(instalaciones)

    def calcular_y_visualizar_coste(self, fecha_inicio, fecha_fin, instalacion, coste_por_hora, coste_presupuestado):
        if self.data_final is None:
            self.procesar_datos()

        # Asegurar que la fecha está en formato date
        self.data_final["fecha"] = pd.to_datetime(self.data_final["fecha"]).dt.date

        # Convertir fechas de entrada
        fecha_inicio = pd.to_datetime(fecha_inicio).date()
        fecha_fin = pd.to_datetime(fecha_fin).date()

        # Filtrar datos
        filtro = (
            (self.data_final["fecha"] >= fecha_inicio) &
            (self.data_final["fecha"] <= fecha_fin) &
            (self.data_final["instalacion"] == instalacion)
        )

        df_filtrado = self.data_final[filtro]

        if df_filtrado.empty:
            messagebox.showwarning("Advertencia", "No se encontraron datos para la instalación en el rango de fechas proporcionado.")
            return None

        # Calcular tiempo y costes
        tiempo_total_invertido = df_filtrado["horas_invertidas"].sum()
        coste_total = tiempo_total_invertido * coste_por_hora
        desviacion = coste_presupuestado - coste_total
        resultado = "Dentro del presupuesto" if coste_total <= coste_presupuestado else "Fuera del presupuesto"

        return {
            "horas_invertidas":tiempo_total_invertido,
            "coste_total": round(coste_total, 2),
            "coste_presupuestado": coste_presupuestado,
            "diferencia_coste": round(desviacion, 2),
            "estado": resultado
        }

class InterfazCosteInstalacion:
    def __init__(self):
        self.ventana = tk.Tk()
        self.ventana.title("Cálculo de Coste de Instalación")
        self.coste_instalacion = CosteInstalacion("")
        self.canvas = None
        self.fig = None
        self.ax = None
        self.crear_widgets()

    def crear_widgets(self):
        # Frame principal
        frame_principal = tk.Frame(self.ventana, padx=20, pady=20)
        frame_principal.pack(expand=True, fill='both')

        # Instrucciones
        label_instrucciones = tk.Label(frame_principal,
            text="Cargar un archivo Excel y calcular los costes de instalación.",
            font=('Arial', 10, 'bold'))
        label_instrucciones.pack(pady=10)

        # Botones de carga y procesamiento
        frame_botones = tk.Frame(frame_principal)
        frame_botones.pack(pady=10)

        boton_cargar_archivo = tk.Button(frame_botones,
            text="Cargar archivo Excel",
            command=self.cargar_archivo,
            width=15)
        boton_cargar_archivo.pack(side=tk.LEFT, padx=5)

        boton_procesar_datos = tk.Button(frame_botones,
            text="Procesar Datos",
            command=self.procesar_datos,
            width=15)
        boton_procesar_datos.pack(side=tk.LEFT, padx=5)

        # Frame para entradas
        frame_entradas = tk.Frame(frame_principal)
        frame_entradas.pack(pady=10)

        # Campos de entrada
        self.crear_campo(frame_entradas, "Fecha de inicio (YYYY-MM-DD):", "fecha_inicio")
        self.crear_campo(frame_entradas, "Fecha de fin (YYYY-MM-DD):", "fecha_fin")
        self.crear_campo(frame_entradas, "Instalación:", "instalacion")
        self.crear_campo(frame_entradas, "Coste por hora (€):", "coste_por_hora")
        self.crear_campo(frame_entradas, "Coste presupuestado (€):", "coste_presupuestado")

        # Botón de cálculo
        boton_calcular_coste = tk.Button(frame_principal,
            text="Calcular Coste",
            command=self.calcular_coste,
            width=15)
        boton_calcular_coste.pack(pady=10)

        # Frame para resultados
        frame_resultados = tk.Frame(frame_principal, relief=tk.GROOVE, borderwidth=2)
        frame_resultados.pack(pady=10, padx=10, fill='x')

        # Etiqueta para resultados
        self.label_resultados = tk.Label(frame_resultados,
            text="Resultados aparecerán aquí",
            justify=tk.LEFT,
            padx=10,
            pady=10)
        self.label_resultados.pack()

        # Frame para gráfica
        self.frame_grafica = tk.Frame(frame_principal)
        self.frame_grafica.pack(pady=10, fill='both', expand=True)

    def crear_campo(self, parent, texto, nombre):
        frame = tk.Frame(parent)
        frame.pack(pady=5)

        label = tk.Label(frame, text=texto, width=25, anchor='e')
        label.pack(side=tk.LEFT, padx=5)

        entry = tk.Entry(frame, width=20)
        entry.pack(side=tk.LEFT, padx=5)

        setattr(self, f"entry_{nombre}", entry)

    def cargar_archivo(self):
        archivo = filedialog.askopenfilename(filetypes=[("Archivos Excel", "*.xls;*.xlsx")])
        if archivo:
            self.coste_instalacion = CosteInstalacion(archivo)
            messagebox.showinfo("Éxito", "Archivo cargado correctamente")

    def procesar_datos(self):
        try:
            self.coste_instalacion.cargar_datos()
            self.coste_instalacion.procesar_datos()
            messagebox.showinfo("Éxito", "Datos procesados correctamente")
        except Exception as e:
            messagebox.showerror("Error", f"Error al procesar datos: {str(e)}")

    def crear_grafica_comparacion(self, resultado, nombre_instalacion):
        # Limpiar el frame de gráfica si hay contenido previo
        for widget in self.frame_grafica.winfo_children():
            widget.destroy()
            
        # Crear figura y ejes
        self.fig, self.ax = plt.subplots(figsize=(8, 6))
        
        # Datos para la gráfica
        coste_total = resultado['coste_total']
        coste_presupuestado = resultado['coste_presupuestado']
        
        # Crear gráfico de barras
        bars = ['Coste Total Invertido', 'Coste Presupuestado']
        valores = [coste_total, coste_presupuestado]
        colores = ['#ff6b6b', '#6b9b42']  # Rojo para invertido, Verde para presupuestado
        
        # Determinar el límite superior del eje Y
        max_valor = max(coste_total, coste_presupuestado)
        # Asegurar que el límite superior sea como mínimo 100000
        y_max = max(100000, round(max_valor * 1.2, -3))  # Redondear al millar superior y añadir 20% de margen
        
        # Configurar el eje Y con límite dinámico
        self.ax.set_ylim(0, y_max)
       # Crear marcas en el eje Y cada 20000 unidades
        self.ax.set_yticks(range(0, y_max + 1, 5000))
        
        # Crear barras
        bar_plot = self.ax.bar(bars, valores, color=colores, width=0.5)
        
        # Añadir línea de límite presupuestado
        self.ax.axhline(y=coste_presupuestado, color='blue', linestyle='--', label='Límite presupuestado')
        self.ax.text(1.1, coste_presupuestado, f'Presupuesto: {coste_presupuestado}€', 
                    color='blue', verticalalignment='bottom')
        
        # Añadir valores en las barras
        for i, rect in enumerate(bar_plot):
            height = rect.get_height()
            self.ax.text(rect.get_x() + rect.get_width()/2., height + 100,
                        f'{valores[i]:.2f}€',
                        ha='center', va='bottom')
        
        # Configuración adicional
        self.ax.set_ylabel('Coste (€)')
        self.ax.set_title(f'Comparación de Costes para {nombre_instalacion.upper()}')
        
        # Formato de los números en el eje Y
        self.ax.get_yaxis().set_major_formatter(
            plt.FuncFormatter(lambda x, loc: "{:,}".format(int(x)).replace(',', '.'))
        )
        # Crear el canvas para la gráfica
        canvas = FigureCanvasTkAgg(self.fig, master=self.frame_grafica)
        canvas.draw()
        canvas.get_tk_widget().pack(side=tk.TOP, fill=tk.BOTH, expand=1)
        
        # Añadir el JSON con los datos en la parte inferior
        json_data = json.dumps(resultado, indent=2)
        label_json = tk.Label(self.frame_grafica, text=json_data, justify=tk.LEFT, 
                            font=('Courier', 9), bg='#f0f0f0', relief=tk.SUNKEN)
        label_json.pack(side=tk.BOTTOM, fill=tk.X, pady=5)


    def calcular_coste(self):
        try:
            # Obtener nombre de la instalación para la gráfica
            nombre_instalacion = self.entry_instalacion.get().upper()

            resultado = self.coste_instalacion.calcular_y_visualizar_coste(
                self.entry_fecha_inicio.get(),
                self.entry_fecha_fin.get(),
                nombre_instalacion,
                float(self.entry_coste_por_hora.get()),
                float(self.entry_coste_presupuestado.get())
            )

            if resultado:
                mensaje = (f"Horas Invertidas: {resultado['horas_invertidas']}h\n"
                           f"Coste Total: {resultado['coste_total']}€\n"
                           f"Coste Presupuestado: {resultado['coste_presupuestado']}€\n"
                           f"Diferencia: {resultado['diferencia_coste']}€\n"
                           f"Estado: {resultado['estado']}")
                self.label_resultados.config(text=mensaje)
               
               # Crear la gráfica de comparación
                self.crear_grafica_comparacion(resultado, nombre_instalacion)
                
                # Ajustar el tamaño de la ventana
                self.ventana.geometry('700x800')

        except Exception as e:
            messagebox.showerror("Error", f"Error al calcular costes: {str(e)}")

    def ejecutar(self):
        # Establecer tamaño inicial
        self.ventana.geometry('700x600')
        
        # Centrar la ventana
        self.ventana.update_idletasks()
        width = self.ventana.winfo_width()
        height = self.ventana.winfo_height()
        x = (self.ventana.winfo_screenwidth() // 2) - (width // 2)
        y = (self.ventana.winfo_screenheight() // 2) - (height // 2)
        self.ventana.geometry('{}x{}+{}+{}'.format(width, height, x, y))

        self.ventana.mainloop()

if __name__ == "__main__":
    app = InterfazCosteInstalacion()
    app.ejecutar()